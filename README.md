# natural
Концепт компилятора естественного языка в качестве ЯП. На данный момент под естественым языком понимается русский язык. Смысл в том, чтобы создать минимальное ядро, разбирающее фразы и предложения. А слова определять отдельно, компилятор лишь должен предоставлять средства для определения слов. Данный концепт в идеале должен быть очень компактным и конкурировать только с forth - то есть минимальная переносимая реализация должна быть простой и лёгкой.

Существуют некоторые предрассудки насчёт того, что естественный язык неточен и многословен, а значит не может быть использован как ЯП. Моё мнение следующее: всё
зависит от слов. Чем точнее словарный запас в какой-то области и чем грамотнее он использован, тем выразительнее язык.

В сравнении с обычными ЯП данный компилятор достаточно низкоуровневый, этакий аналог форта. Определять можно только слова. Слова имеют лишь тип речи, а значит могут быть действиями, предметами или свойствами. Разработчик используя определение слов сам пишет логику базовых блоков. То есть никакого встроенного ООП или любых других парадигм тут нет. Также нет и завязки на какие-то конкретные возможности аппаратной архитектуры(вроде стека или регистров). Также в идеале, это должно позволить создавать разные словари для совершенно разных задач. То есть использовать язык например как высокоуровневый(подобие скажем javascript, perl и тд), низкоуровневый(подобие C, forth и тд) и даже язык определения железа(подобие verilor и прочих).

Есть ещё один важный момент. Естественный язык это не только описание действий, как обычные ЯП. Это ещё и описание прошлых событий, их последовательностей и как следствие хранение информации. То есть проводя аналогии в программировании это ещё и аналог log, data, database и даже вещей вроде lisp image с полным хранением всей истории изменений. Вот эти важные особенности естественного языка, так же в идеале, мне бы хотелось использовать при написании и использовании программ. То есть не только писать программы на ЕС, но и хранить историю изменения программы и данных(а при таком подходе получается нет разницы кода и данных).
